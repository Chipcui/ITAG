
=head1 NAME

CXGN::ITAG::Release::Statistics - object that calculates statistics about an ITAG release

=head1 SYNOPSIS

  my $stats = CXGN::ITAG::Release::Statistics->new( release => $release );
  say "number of genes in release: ".$stats->gene_length->count;

=cut

package CXGN::ITAG::Release::Statistics;
use Moose;
use namespace::autoclean;
use MooseX::Types::Path::Class qw/ File Dir /;

use Bio::GFF3::LowLevel 'gff3_parse_feature';

use List::MoreUtils 'uniq';
use Hash::Util qw/ lock_hash /;

use Statistics::Descriptive;

=head1 ATTRIBUTES

All attributes are B<read-only>.

=head2 Files (L<Path::Class::File>)

genomic_gff3

protein_fasta

=head2 L<Statistics::Descriptive::Full> attributes

gene_model_length

intergenic_length

exons_per_gene_model

GO_terms_per_mrna

=head2  L<Statistics::Descriptive::Sparse> attributes

exon_length

intron_length

=head2 Counters

genes_with_splice_variants

mapped_ests

gene_models

gene_models_with_human_desc

gene_models_with_GO_terms

genomic_bases

protein_coding_with_supporting_cdna

protein_coding_with_supporting_prot

protein_coding_without_supporting_cdna

protein_coding_without_supporting_prot

protein_coding_with_supporting_cdna_and_protein

protein_coding_with_supporting_cdna_or_protein

protein_coding_with_supporting_only_cdna

protein_coding_with_supporting_only_protein

protein_coding_with_supporting_none

unique_GO_terms

=cut

# init a bunch of descriptive statistics keepers
has $_->[0] => (
    is      => 'ro',
    default => $_->[1] ? sub { Statistics::Descriptive::Full->new } : sub { Statistics::Descriptive::Sparse->new },
    handles => {
        'add_'.$_->[0]   => 'add_data'
       },
   ) for
    [qw[ gene_model_length        full ]],
    [qw[ intergenic_length        full ]],
    [qw[ exon_length              full ]],
    [qw[ intron_length            full ]],
    [qw[ exons_per_gene_model     full ]],
    [qw[ GO_terms_per_mrna        full ]];

# init some counters for simpler things
has $_ => (
    traits  => ['Counter'],
    is      => 'ro',
    #isa     => 'Int',
    default => 0,
    handles => {
        "inc_$_" => 'inc',
    },
   ) for qw(
             mapped_ests
             gene_models
             gene_models_with_human_desc
             gene_models_with_GO_terms

             genomic_bases

             protein_coding_with_supporting_cdna
             protein_coding_with_supporting_prot
             protein_coding_without_supporting_cdna
             protein_coding_without_supporting_prot

             protein_coding_with_supporting_cdna_or_protein

             protein_coding_with_supporting_cdna_and_protein
             protein_coding_with_supporting_only_cdna
             protein_coding_with_supporting_only_protein
             protein_coding_with_supporting_none
           );

has $_ => (
    is      => 'rw',
    #isa     => 'Int',
    default => 0,
   ) for qw( unique_GO_terms
             genes_with_splice_variants
           );

has 'release' => (
    is => 'ro',
    isa => 'CXGN::ITAG::Release',
   );

has 'gene_model_gff3' => (
    is => 'ro',
    isa => File,
    coerce => 1,
    lazy_build => 1,
   ); sub _build_gene_model_gff3 {
       shift->release->get_file_info('models_gff3')->{file};
   }

has 'cdna_gff3' => (
    is => 'ro',
    isa => File,
    coerce => 1,
    lazy_build => 1,
   ); sub _build_cdna_gff3 {
       shift->release->get_file_info('cdna_algn_gff3')->{file};
   }


has 'protein_fasta' => (
    is => 'ro',
    isa => File,
    coerce => 1,
    lazy_build => 1,
   ); sub _build_protein_fasta {
       shift->release->get_file_info('protein_fasta')->{file},
   }


#go through all the files in the release, collect statistics about them
sub BUILD {
  my ( $self ) = @_;
  $self->_analyze_genomic_gff3;
  $self->_analyze_protein_fasta;
}

sub _analyze_protein_fasta {
    my $self = shift;

    # get statistics about gene models from the gene description codes
    # generated by EuGene in the deflines of the protein and CDS fasta
    # files
    my $deflines = $self->protein_fasta->openr;
    while (my $line = <$deflines>) {
        next unless $line =~ />/;
        $line =~ s/^\s*>//;     #<trim off the beginning symbol
        my ($ident,$def) = split /\s+/,$line,2;
        if (my $desc = $self->_parse_gene_description($def)) {
            my $full_cdna = $desc->{cdna_complete_coverage};
            my $cdna      = $full_cdna || $desc->{cds_from_cdna_aln};
            my $prot      = $desc->{gene_model_from_prot_aln};

            # count various logical combinations of protein and cdna support
            $self->inc_protein_coding_with_supporting_cdna             if  $cdna;
            $self->inc_protein_coding_with_supporting_prot             if            $prot;
            $self->inc_protein_coding_without_supporting_cdna          if !$cdna;
            $self->inc_protein_coding_without_supporting_prot          if           !$prot;
            $self->inc_protein_coding_with_supporting_cdna_or_protein  if  $cdna ||  $prot;
            $self->inc_protein_coding_with_supporting_cdna_and_protein if  $cdna &&  $prot;
            $self->inc_protein_coding_with_supporting_only_cdna        if  $cdna && !$prot;
            $self->inc_protein_coding_with_supporting_only_protein     if !$cdna &&  $prot;
            $self->inc_protein_coding_with_supporting_none             if !$cdna && !$prot;

            #         { # calculate length class stats
            #             $stats{'gene_model_length_classes'} ||= {};
            #             my $lc = $desc->{length_class};
            #             $lc = 'none' unless defined $lc;
            #             $stats{'gene_model_length_classes'}{$lc}++;
            #         }
        } else {
            chomp $line;
            warn "WARNING: unable to find gene evidence description in defline '$line'\n"
                unless (our $warned_about_gene_evidence)++;
            next;
        }
    }
}

sub _analyze_genomic_gff3 { # process the genomic gff3
    my $self = shift;

    #prepare vars for gathering stats
    my %go_terms_seen;
    my $previous_exon_end = {};
    my $previous_gene_end = {};
    my $previous_gene_exon_count = {};
    my $gene_exon_ct      = 0;
    my %gene_mrna_counts;
    my %mrna_exon_counts;
    my %ests_seen;

    #open the aggregated GFF3 file
    my $genes_in = $self->gene_model_gff3->openr;
    while ( my $line = <$genes_in> ) {
        chomp $line;
        if( $line =~ /^##sequence-region\s+\S+\s+(\d+)\s+(\d+)/ ) {
            $self->inc_genomic_bases( $2 - $1 + 1 );
        }

        next if $line =~ /^#/;

        my $f = gff3_parse_feature( $line );
        my ($ref,$src,$type,$start,$end,$strand) = map {$_ or die} @{$f}{qw{ seq_id source type start end strand }};
        $src = lc $src;
        my $length = $end-$start+1;

        ### src: $src
        ### type: $type
        if ( $src eq 'itag_renaming' || $src eq 'itag_eugene' ) {
            if ( $type eq 'exon' ) {
                $self->add_exon_length( $length );
                my $parent = $f->{attributes}{Parent}[0];
                if ( my $p = $previous_exon_end->{ $parent } ) {
                    my $intron_length = $start - $p + 1;
                    $self->add_intron_length( $intron_length );
                }
                $previous_exon_end->{$parent} = $end;

                ### parent: $parent
                $mrna_exon_counts{$parent}++;

            } elsif ( $type eq 'gene' ) {
                ### length: $gene_length
                if ( my $p = $previous_gene_end->{$strand} ) {
                    if( $p->[0] eq $ref ) {
                        my $length = $start - $p->[1] + 1;
                        $length = 0 if $length < 0;
                        $self->add_intergenic_length( $length );
                    }
                }
                $previous_gene_end->{$strand} = [$ref,$end];
            } elsif ( $type eq 'mRNA' ) {
                $self->add_gene_model_length( $length );
                $previous_exon_end->{ $f->{attributes}{ID}[0] } = undef; #< new mrna on this strand
                $self->inc_gene_models;
                my ($parent) = $line =~ /Parent=gene:([^;\n]+)/ or die "cannot parse parent from gff3 line:\n$line\n";
                ### parent: $parent
                $gene_mrna_counts{$parent}++;
                if ( $line =~ /Note=/ ) {
                    $self->inc_gene_models_with_human_desc;
                }
                if ( my @go_terms = uniq( map { split /,/, $_ } $line =~ /(?:Ontology_term|interpro2go_term|sifter_term)=([^;\n]+)/g )) {
                    $self->inc_gene_models_with_GO_terms;
                    $self->add_GO_terms_per_mrna( scalar @go_terms );
                    $go_terms_seen{$_} = 1 for @go_terms;
                    ### terms: @go_terms
                } else {
                    $self->add_GO_terms_per_mrna( 0 );
                }
            }
        }
    }

    my $transcripts_in = $self->cdna_gff3->openr;
    while( my $l = <$transcripts_in> ) {
        next if $l =~ /^#/;
        my $f = gff3_parse_feature( $l );
        if ( $f->{source} =~ /^itag_transcripts_/i ) {
            if ( $f->{type} eq 'match' ) {
                my @tgts = map [split], @{ $f->{attributes}{Target} || [] };
                ### targets: @tgts

                unless ( $ests_seen{ $tgts[0][0] }++ ) {
                    $self->inc_mapped_ests;
                }
            }
        }
    }

    # calculate number of unique ontology terms
    $self->unique_GO_terms( scalar keys %go_terms_seen );

    ## aggregate the splice variant statistics
    # currently just counting how many genes have been annotated with splice variants
    $self->genes_with_splice_variants( scalar grep $_ > 1, values %gene_mrna_counts );

    $self->add_exons_per_gene_model( values %mrna_exon_counts );
}

#given a line of text containing a gene description somewhere, parse
#it and return a hashref of its contents, or nothing if no description
#was found
sub _parse_gene_description {
    my ($self,$text) = @_;

    my %stuff;

    @stuff{qw/year cdna_complete_coverage gene_model_from_prot_aln cds_from_cdna_aln program length_class/}
        = $text =~ / \b (\d\d) F (\d) H (\d) E (\d) I ([A-Z]{2}) (L (\d))? \b /x
            or return;

    my %program_map = ( EG => 'EuGene' );
    $stuff{program} = $program_map{$stuff{program}}
        or die "unknown program code '$stuff{program}' found in gene description";

    lock_hash(%stuff);

    return \%stuff;
}

__PACKAGE__->meta->make_immutable;
1;
