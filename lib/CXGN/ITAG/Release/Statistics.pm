
=head1 NAME

CXGN::ITAG::Release::Statistics - object that calculates statistics about an ITAG release

=head1 SYNOPSIS

  my $stats = CXGN::ITAG::Release::Statistics->new( release => $release );
  say "number of genes in release: ".$stats->gene_length->count;

=cut

package CXGN::ITAG::Release::Statistics;
use namespace::autoclean;
use Moose;
use MooseX::Types::Path::Class;

use Hash::Util qw/ lock_hash /;

use Statistics::Descriptive;

=head1 ATTRIBUTES

All attributes are B<read-only>.

=head2 Files (L<Path::Class::File>)

genomic_gff3

protein_fasta

=head2 L<Statistics::Descriptive::Full> attributes

gene_model_length

intergenic_length

exons_per_gene_model

ontology_terms_per_mrna

=head2  L<Statistics::Descriptive::Sparse> attributes

exon_length

intron_length

=head2 Counters

genes_with_splice_variants

mapped_ests

gene_models

gene_models_with_human_desc

genomic_bases

protein_coding_with_supporting_cdna

protein_coding_with_supporting_prot

protein_coding_without_supporting_cdna

protein_coding_without_supporting_prot

protein_coding_with_supporting_cdna_and_protein

protein_coding_with_supporting_only_cdna

protein_coding_with_supporting_only_protein

protein_coding_with_supporting_none

unique_ontology_terms

=cut

# init a bunch of descriptive statistics keepers
has $_->[0] => (
    is      => 'ro',
    default => $_->[1] ? sub { Statistics::Descriptive::Full->new } : sub { Statistics::Descriptive::Sparse->new },
    handles => {
        'add_'.$_->[0]   => 'add_data'
       },
   ) for
    [qw[ gene_model_length        full ]],
    [qw[ intergenic_length        full ]],
    [qw[ exon_length              full ]],
    [qw[ intron_length            full ]],
    [qw[ exons_per_gene_model     full ]],
    [qw[ ontology_terms_per_mrna  full ]];

# init some counters for simpler things
has $_ => (
    traits  => ['Counter'],
    is      => 'ro',
    #isa     => 'Int',
    default => 0,
    handles => {
        "inc_$_" => 'inc',
    },
   ) for qw(
             mapped_ests
             gene_models
             gene_models_with_human_desc

             genomic_bases

             protein_coding_with_supporting_cdna
             protein_coding_with_supporting_prot
             protein_coding_without_supporting_cdna
             protein_coding_without_supporting_prot

             protein_coding_with_supporting_cdna_and_protein
             protein_coding_with_supporting_only_cdna
             protein_coding_with_supporting_only_protein
             protein_coding_with_supporting_none
           );

has $_ => (
    is      => 'rw',
    #isa     => 'Int',
    default => 0,
   ) for qw( unique_ontology_terms
             genes_with_splice_variants
           );

has 'release' => (
    is => 'ro',
    isa => 'CXGN::ITAG::Release',
    required => 1,
   );

has 'genomic_gff3' => (
    is => 'ro',
    isa => 'Path::Class::File',
    coerce => 1,
    lazy_build => 1,
   ); sub _build_genomic_gff3 {
       shift->release->get_file_info('combi_genomic_gff3')->{file};
   }

has 'protein_fasta' => (
    is => 'ro',
    isa => 'Path::Class::File',
    coerce => 1,
    lazy_build => 1,
   ); sub _build_protein_fasta {
       shift->release->get_file_info('protein_fasta')->{file},
   }


#go through all the files in the release, collect statistics about them,
#return it as a locked hashref
sub BUILD {
  my ( $self ) = @_;

  print "collecting statistics...\n";

  $self->_analyze_genomic_gff3;
  $self->_analyze_protein_fasta;
}

sub _analyze_protein_fasta {
    my $self = shift;

  # get statistics about gene models from the gene description codes
  # generated by EuGene in the deflines of the protein and CDS fasta
  # files
    my $deflines = $self->protein_fasta->openr;
    while (my $line = <$deflines>) {
        next unless $line =~ />/;
        $line =~ s/^\s*>//;     #<trim off the beginning symbol
        my ($ident,$def) = split /\s+/,$line,2;
        if (my $desc = $self->_parse_gene_description($def)) {
            my $full_cdna = $desc->{cdna_complete_coverage};
            my $cdna      = $full_cdna || $desc->{cds_from_cdna_aln};
            my $prot      = $desc->{gene_model_from_prot_aln};

            # count various logical combinations of protein and cdna support
            $self->inc_protein_coding_with_supporting_cdna             if  $cdna;
            $self->inc_protein_coding_with_supporting_prot             if            $prot;
            $self->inc_protein_coding_without_supporting_cdna          if !$cdna;
            $self->inc_protein_coding_without_supporting_prot          if           !$prot;
            $self->inc_protein_coding_with_supporting_cdna_and_protein if  $cdna &&  $prot;
            $self->inc_protein_coding_with_supporting_only_cdna        if  $cdna && !$prot;
            $self->inc_protein_coding_with_supporting_only_protein     if !$cdna &&  $prot;
            $self->inc_protein_coding_with_supporting_none             if !$cdna && !$prot;

            #         { # calculate length class stats
            #             $stats{'gene_model_length_classes'} ||= {};
            #             my $lc = $desc->{length_class};
            #             $lc = 'none' unless defined $lc;
            #             $stats{'gene_model_length_classes'}{$lc}++;
            #         }
        } else {
            chomp $line;
            die "ERROR: no parsable gene description found in defline $line\n";
            next;
        }
    }
}

sub _analyze_genomic_gff3 { # process the genomic gff3
    my $self = shift;

    #prepare vars for gathering stats
    my %ontology_terms_seen;
    my $previous_exon_end = {};
    my $previous_gene_end = {};
    my $previous_gene_exon_count = {};
    my $gene_exon_ct      = 0;
    my %gene_mrna_counts;
    my %mrna_exon_counts;
    my %ests_seen;

    #open the aggregated GFF3 file
    my $combi_in = $self->genomic_gff3->openr;
    while ( my $line = <$combi_in> ) {
        chomp $line;
        if( $line =~ /^##sequence-region\s+\S+\s+(\d+)\s+(\d+)/ ) {
            $self->inc_genomic_bases( $2 - $1 + 1 );
        }

        next if $line =~ /^#/;
        ### line: $line
        my @f = split /\t/, $line, 9;
        my ($ref,$src,$type,$start,$end,undef,$strand,undef,$attr) = split /\t/, $line, 9;
        $src = lc $src;
        my $length = $end-$start+1;

        ### src: $src
        ### type: $type
        if ( $src eq 'itag_renaming' ) {
            if ( $type eq 'exon' ) {
                $self->add_exon_length( $length );
                if ( my $p = $previous_exon_end->{$strand} ) {
                    $self->add_intron_length( $start - $p + 1 );
                }
                $previous_exon_end->{$strand} = $end;

                my ($parent) = $line =~ /Parent=mRNA:([^;\n]+)/ or die "cannot parse parent from gff3 line:\n$line\n";
                ### parent: $parent
                $mrna_exon_counts{$parent}++;

            } elsif ( $type eq 'gene' ) {
                ### length: $gene_length
                if ( my $p = $previous_gene_end->{$strand} ) {
                    if( $p->[0] eq $ref ) {
                        $self->add_intergenic_length( $start - $p->[1] + 1 );
                    }
                }
                $previous_gene_end->{$strand} = [$ref,$end];
            } elsif ( $type eq 'mRNA' ) {
                $self->add_gene_model_length( $length );
                $previous_exon_end->{$strand} = undef; #< new mrna on this strand
                $self->inc_gene_models;
                my ($parent) = $line =~ /Parent=gene:([^;\n]+)/ or die "cannot parse parent from gff3 line:\n$line\n";
                ### parent: $parent
                $gene_mrna_counts{$parent}++;
                if ( $line =~ /functional_description=/ ) {
                    $self->inc_gene_models_with_human_desc;
                }
                if ( my @terms = $line =~ /Ontology_term=([^;\n]+)/g ) {
                    $self->add_ontology_terms_per_mrna( scalar @terms );
                    $ontology_terms_seen{$_} = 1 for @terms;
                    ### terms: @terms
                } else {
                    $self->add_ontology_terms_per_mrna( 0 );
                }
            }
        } elsif ( $src =~ /^itag_transcripts_/i ) {
            if ( $type eq 'match' ) {
                my @tgts = map [split], $line =~ /Target=([^;\n]+)/g;
                ### targets: @tgts

                unless ( $ests_seen{ $tgts[0][0] }++ ) {
                    $self->inc_mapped_ests;
                }
            }
        }
    }
    close $combi_in;

    # calculate number of unique ontology terms
    $self->unique_ontology_terms( scalar keys %ontology_terms_seen );

    ## aggregate the splice variant statistics
    # currently just counting how many genes have been annotated with splice variants
    $self->genes_with_splice_variants( scalar grep $_ > 1, values %gene_mrna_counts );

    $self->add_exons_per_gene_model( values %mrna_exon_counts );
}

#given a line of text containing a gene description somewhere, parse
#it and return a hashref of its contents, or nothing if no description
#was found
sub _parse_gene_description {
  my ($self,$text) = @_;

  my %stuff;

  @stuff{qw/year cdna_complete_coverage gene_model_from_prot_aln cds_from_cdna_aln program length_class/}
    = $text =~ / \b (\d\d) F (\d) H (\d) E (\d) I ([A-Z]{2}) (L (\d))? \b /x
      or return;

  my %program_map = ( EG => 'EuGene' );
  $stuff{program} = $program_map{$stuff{program}} or die "unknown program code '$stuff{program}' found in gene description";

  lock_hash(%stuff);

  return \%stuff;
}

__PACKAGE__->meta->make_immutable;
1;
